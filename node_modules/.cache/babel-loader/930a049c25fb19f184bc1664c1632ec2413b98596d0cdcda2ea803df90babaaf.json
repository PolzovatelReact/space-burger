{"ast":null,"code":"import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\n// Начальное состояние\nconst initialState = {\n  ingredients: [],\n  // Список ингредиентов\n  isLoading: false,\n  // Флаг загрузки\n  hasError: false // Флаг ошибки\n};\nexport const fetchIngredients = createAsyncThunk(\"ingredients/fetchIngredients\", async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await fetch(\"https://norma.nomoreparties.space/api/ingredients\"); // Отправляем запрос на сервер\n    const data = await response.json(); // Получаем ответ в виде json\n    return data.data; // Возвращает массив ингредиентов/    2я data - берется из структуры ответа API\n  } catch (error) {\n    return rejectWithValue(\"Ошибка загрузки ингредиентов\");\n  }\n});\n\n// export const fetchIngredients = createAsyncThunk(\n//   \"ingredients/fetchIngredients\",\n//   // Declare the type your function argument here:\n//   async (userId: number) => {\n//     const response = await fetch(\n//       `https://norma.nomoreparties.space/api/ingredients`\n//     );\n//     // Inferred return type: Promise<MyData>\n//     return (await response.json()) as Product[];\n//   }\n// );\n\nconst ingewdientsSlice = createSlice({\n  name: \"ingredients\",\n  // Определяет имя слайса в хранилеще редакс\n  initialState,\n  // Начальное состояние\n  reducers: {},\n  // Здесь можно описать синхронные экшены\n  extraReducers: builder => {\n    // extraReducers описывает обработку асинхронных экшенов fetchIngredients\n    builder.addCase(fetchIngredients.pending, state => {\n      // pending  запрос отправлен\n      state.isLoading = true;\n      state.hasError = false;\n    }).addCase(fetchIngredients.fulfilled, (state, action) => {\n      // fulfilled успешный ответ от сервера\n      state.isLoading = false;\n      state.ingredients = action.payload; // Этот оператор ?? (nullish coalescing) гарантирует, что если action.payload будет undefined, то присвоится пустой массив [].\n    }).addCase(fetchIngredients.rejected, state => {\n      // rejected запрос не удался\n      state.isLoading = false;\n      state.hasError = true;\n    });\n  }\n});\nexport default ingewdientsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","initialState","ingredients","isLoading","hasError","fetchIngredients","_","rejectWithValue","response","fetch","data","json","error","ingewdientsSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","rejected","reducer"],"sources":["D:/Yandex/step-2-sprint-1-step-2/step-2-sprint-1-step-2/src/store/slices/ingredientsSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\r\nimport { Product } from \"../../types/productTypes\";\r\n\r\ninterface IngredientsState {\r\n  ingredients: Product[];\r\n  isLoading: boolean;\r\n  hasError: boolean;\r\n}\r\n\r\n// Начальное состояние\r\nconst initialState: IngredientsState = {\r\n  ingredients: [], // Список ингредиентов\r\n  isLoading: false, // Флаг загрузки\r\n  hasError: false, // Флаг ошибки\r\n};\r\n\r\nexport const fetchIngredients = createAsyncThunk<Product[], void>(\r\n  \"ingredients/fetchIngredients\",\r\n  async (_, { rejectWithValue }) => {\r\n    try {\r\n      const response = await fetch(\r\n        \"https://norma.nomoreparties.space/api/ingredients\"\r\n      ); // Отправляем запрос на сервер\r\n      const data = await response.json(); // Получаем ответ в виде json\r\n      return data.data as Product[]; // Возвращает массив ингредиентов/    2я data - берется из структуры ответа API\r\n    } catch (error) {\r\n      return rejectWithValue(\"Ошибка загрузки ингредиентов\");\r\n    }\r\n  }\r\n);\r\n\r\n// export const fetchIngredients = createAsyncThunk(\r\n//   \"ingredients/fetchIngredients\",\r\n//   // Declare the type your function argument here:\r\n//   async (userId: number) => {\r\n//     const response = await fetch(\r\n//       `https://norma.nomoreparties.space/api/ingredients`\r\n//     );\r\n//     // Inferred return type: Promise<MyData>\r\n//     return (await response.json()) as Product[];\r\n//   }\r\n// );\r\n\r\nconst ingewdientsSlice = createSlice({\r\n  name: \"ingredients\", // Определяет имя слайса в хранилеще редакс\r\n  initialState, // Начальное состояние\r\n  reducers: {}, // Здесь можно описать синхронные экшены\r\n  extraReducers: (builder) => {\r\n    // extraReducers описывает обработку асинхронных экшенов fetchIngredients\r\n    builder\r\n      .addCase(fetchIngredients.pending, (state) => {\r\n        // pending  запрос отправлен\r\n        state.isLoading = true;\r\n        state.hasError = false;\r\n      })\r\n      .addCase(fetchIngredients.fulfilled, (state, action) => {\r\n        // fulfilled успешный ответ от сервера\r\n        state.isLoading = false;\r\n        state.ingredients = action.payload; // Этот оператор ?? (nullish coalescing) гарантирует, что если action.payload будет undefined, то присвоится пустой массив [].\r\n      })\r\n      .addCase(fetchIngredients.rejected, (state) => {\r\n        // rejected запрос не удался\r\n        state.isLoading = false;\r\n        state.hasError = true;\r\n      });\r\n  },\r\n});\r\nexport default ingewdientsSlice.reducer;\r\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,gBAAgB,QAAQ,kBAAkB;AAShE;AACA,MAAMC,YAA8B,GAAG;EACrCC,WAAW,EAAE,EAAE;EAAE;EACjBC,SAAS,EAAE,KAAK;EAAE;EAClBC,QAAQ,EAAE,KAAK,CAAE;AACnB,CAAC;AAED,OAAO,MAAMC,gBAAgB,GAAGL,gBAAgB,CAC9C,8BAA8B,EAC9B,OAAOM,CAAC,EAAE;EAAEC;AAAgB,CAAC,KAAK;EAChC,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAC1B,mDACF,CAAC,CAAC,CAAC;IACH,MAAMC,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;IACpC,OAAOD,IAAI,CAACA,IAAI,CAAc,CAAC;EACjC,CAAC,CAAC,OAAOE,KAAK,EAAE;IACd,OAAOL,eAAe,CAAC,8BAA8B,CAAC;EACxD;AACF,CACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMM,gBAAgB,GAAGd,WAAW,CAAC;EACnCe,IAAI,EAAE,aAAa;EAAE;EACrBb,YAAY;EAAE;EACdc,QAAQ,EAAE,CAAC,CAAC;EAAE;EACdC,aAAa,EAAGC,OAAO,IAAK;IAC1B;IACAA,OAAO,CACJC,OAAO,CAACb,gBAAgB,CAACc,OAAO,EAAGC,KAAK,IAAK;MAC5C;MACAA,KAAK,CAACjB,SAAS,GAAG,IAAI;MACtBiB,KAAK,CAAChB,QAAQ,GAAG,KAAK;IACxB,CAAC,CAAC,CACDc,OAAO,CAACb,gBAAgB,CAACgB,SAAS,EAAE,CAACD,KAAK,EAAEE,MAAM,KAAK;MACtD;MACAF,KAAK,CAACjB,SAAS,GAAG,KAAK;MACvBiB,KAAK,CAAClB,WAAW,GAAGoB,MAAM,CAACC,OAAO,CAAC,CAAC;IACtC,CAAC,CAAC,CACDL,OAAO,CAACb,gBAAgB,CAACmB,QAAQ,EAAGJ,KAAK,IAAK;MAC7C;MACAA,KAAK,CAACjB,SAAS,GAAG,KAAK;MACvBiB,KAAK,CAAChB,QAAQ,GAAG,IAAI;IACvB,CAAC,CAAC;EACN;AACF,CAAC,CAAC;AACF,eAAeS,gBAAgB,CAACY,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}